/* Description and License
 * A Java library that wraps the functionality of the native image 
 * processing library OpenCV
 *
 * (c) Sigurdur Orn Adalgeirsson (siggi@alum.mit.edu)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA  02111-1307  USA
 */
 
package sj.opencv.jna.calib3d;
import com.sun.jna.Library;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.FloatByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import sj.opencv.jna.calib3d.CvStereoBMState.ByReference;
import sj.opencv.jna.cxcore.CvMat;
import sj.opencv.jna.cxcore.CvPoint2D32f;
import sj.opencv.jna.cxcore.CvPoint2D64f;
import sj.opencv.jna.cxcore.CvPoint3D32f;
import sj.opencv.jna.cxcore.CvPoint3D64f;
import sj.opencv.jna.cxcore.CvRect;
import sj.opencv.jna.cxcore.JNAIplImage;
import sj.opencv.jna.highgui.HighguiLibrary.CvArr;
/**
 * JNA Wrapper for library <b>calib3d</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Calib3dLibrary extends Library {
	public static final int CV_ITERATIVE = (int)0;
	/// F.Moreno-Noguer, V.Lepetit and P.Fua "EPnP: Efficient Perspective-n-Point Camera Pose Estimation"
	public static final int CV_EPNP = (int)1;
	/// X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang; "Complete Solution Classification for the Perspective-Three-Point Problem"
	public static final int CV_P3P = (int)2;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_CB_FILTER_QUADS = (int)4;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_STEREO_BM_NARROW = (int)2;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_FM_RANSAC_ONLY = (int)8;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_FM_LMEDS = (int)4;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_USE_INTRINSIC_GUESS = (int)1;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_FIX_ASPECT_RATIO = (int)2;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_STEREO_BM_FISH_EYE = (int)1;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_FM_LMEDS_ONLY = (int)4;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_FIX_INTRINSIC = (int)256;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_LMEDS = (int)4;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_FIX_PRINCIPAL_POINT = (int)4;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_FM_8POINT = (int)2;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_FM_7POINT = (int)1;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_RANSAC = (int)8;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_FIX_FOCAL_LENGTH = (int)16;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_ZERO_TANGENT_DIST = (int)8;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_SAME_FOCAL_LENGTH = (int)512;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_STEREO_BM_XSOBEL = (int)1;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_CB_NORMALIZE_IMAGE = (int)2;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_ZERO_DISPARITY = (int)1024;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_STEREO_BM_NORMALIZED_RESPONSE = (int)0;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_CB_ADAPTIVE_THRESH = (int)1;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_RATIONAL_MODEL = (int)16384;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_FM_RANSAC = (int)8;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_CB_FAST_CHECK = (int)8;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_STEREO_BM_BASIC = (int)0;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_FIX_K6 = (int)8192;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_FIX_K5 = (int)4096;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_FIX_K4 = (int)2048;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_FIX_K3 = (int)128;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_FIX_K2 = (int)64;
	/// <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp</i>
	public static final int CV_CALIB_FIX_K1 = (int)32;
	/**
	 * Allocates and initializes CvPOSITObject structure before doing cvPOSIT<br>
	 * Original signature : <code>CvPOSITObject* cvCreatePOSITObject(CvPoint3D32f*, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5308</i>
	 */
	Calib3dLibrary.CvPOSITObject cvCreatePOSITObject(CvPoint3D32f points, int point_count);
	/**
	 * Runs POSIT (POSe from ITeration) algorithm for determining 3d position of<br>
	 * an object given its model and projection in a weak-perspective case<br>
	 * Original signature : <code>void cvPOSIT(CvPOSITObject*, CvPoint2D32f*, double, CvTermCriteria, float*, float*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5314</i><br>
	 * @deprecated use the safer methods {@link #cvPOSIT(sj.opencv.jna.calib3d.Calib3dLibrary.CvPOSITObject, sj.opencv.jna.cxcore.CvPoint2D32f, double, sj.opencv.jna.cxcore.CvTermCriteria.ByValue, java.nio.FloatBuffer, java.nio.FloatBuffer)} and {@link #cvPOSIT(sj.opencv.jna.calib3d.Calib3dLibrary.CvPOSITObject, sj.opencv.jna.cxcore.CvPoint2D32f, double, sj.opencv.jna.cxcore.CvTermCriteria.ByValue, com.sun.jna.ptr.FloatByReference, com.sun.jna.ptr.FloatByReference)} instead
	 */
	@Deprecated
	void cvPOSIT(Calib3dLibrary.CvPOSITObject posit_object, CvPoint2D32f image_points, double focal_length, sj.opencv.jna.cxcore.CvTermCriteria.ByValue criteria, FloatByReference rotation_matrix, FloatByReference translation_vector);
	/**
	 * Runs POSIT (POSe from ITeration) algorithm for determining 3d position of<br>
	 * an object given its model and projection in a weak-perspective case<br>
	 * Original signature : <code>void cvPOSIT(CvPOSITObject*, CvPoint2D32f*, double, CvTermCriteria, float*, float*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5314</i>
	 */
	void cvPOSIT(Calib3dLibrary.CvPOSITObject posit_object, CvPoint2D32f image_points, double focal_length, sj.opencv.jna.cxcore.CvTermCriteria.ByValue criteria, FloatBuffer rotation_matrix, FloatBuffer translation_vector);
	/**
	 * Releases CvPOSITObject structure<br>
	 * Original signature : <code>void cvReleasePOSITObject(CvPOSITObject**)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5319</i><br>
	 * @deprecated use the safer method {@link #cvReleasePOSITObject(sj.opencv.jna.calib3d.Calib3dLibrary.CvPOSITObject[])} instead
	 */
	@Deprecated
	void cvReleasePOSITObject(PointerByReference posit_object);
	/**
	 * Releases CvPOSITObject structure<br>
	 * Original signature : <code>void cvReleasePOSITObject(CvPOSITObject**)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5319</i>
	 */
	void cvReleasePOSITObject(Calib3dLibrary.CvPOSITObject posit_object[]);
	/**
	 * updates the number of RANSAC iterations<br>
	 * Original signature : <code>int cvRANSACUpdateNumIters(double, double, int, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5324</i>
	 */
	int cvRANSACUpdateNumIters(double p, double err_prob, int model_points, int max_iters);
	/**
	 * Original signature : <code>void cvConvertPointsHomogeneous(const CvMat*, CvMat*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5326</i>
	 */
	void cvConvertPointsHomogeneous(CvMat src, CvMat dst);
	/**
	 * Original signature : <code>int cvFindFundamentalMat(const CvMat*, const CvMat*, CvMat*, int, double, double, CvMat*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5335</i>
	 */
	int cvFindFundamentalMat(CvMat points1, CvMat points2, CvMat fundamental_matrix, int method, double param1, double param2, CvMat status);
	/**
	 * For each input point on one of images<br>
	 * computes parameters of the corresponding<br>
	 * epipolar line on the other image<br>
	 * Original signature : <code>void cvComputeCorrespondEpilines(const CvMat*, int, const CvMat*, CvMat*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5342</i>
	 */
	void cvComputeCorrespondEpilines(CvMat points, int which_image, CvMat fundamental_matrix, CvMat correspondent_lines);
	/**
	 * Original signature : <code>void cvTriangulatePoints(CvMat*, CvMat*, CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5344</i>
	 */
	void cvTriangulatePoints(CvMat projMatr1, CvMat projMatr2, CvMat projPoints1, CvMat projPoints2, CvMat points4D);
	/**
	 * Original signature : <code>void cvCorrectMatches(CvMat*, CvMat*, CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5346</i>
	 */
	void cvCorrectMatches(CvMat F, CvMat points1, CvMat points2, CvMat new_points1, CvMat new_points2);
	/**
	 * Computes the optimal new camera matrix according to the free scaling parameter alpha:<br>
	 * alpha=0 - only valid pixels will be retained in the undistorted image<br>
	 * alpha=1 - all the source image pixels will be retained in the undistorted image<br>
	 * Original signature : <code>void cvGetOptimalNewCameraMatrix(const CvMat*, const CvMat*, CvSize, double, CvMat*, CvSize, CvRect*, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5353</i>
	 */
	void cvGetOptimalNewCameraMatrix(CvMat camera_matrix, CvMat dist_coeffs, sj.opencv.jna.cxcore.CvSize.ByValue image_size, double alpha, CvMat new_camera_matrix, sj.opencv.jna.cxcore.CvSize.ByValue new_imag_size, CvRect valid_pixel_ROI, int center_principal_point);
	/**
	 * Converts rotation vector to rotation matrix or vice versa<br>
	 * Original signature : <code>int cvRodrigues2(const CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5358</i>
	 */
	int cvRodrigues2(CvMat src, CvMat dst, CvMat jacobian);
	/**
	 * Finds perspective transformation between the object plane and image (view) plane<br>
	 * Original signature : <code>int cvFindHomography(const CvMat*, const CvMat*, CvMat*, int, double, CvMat*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5363</i>
	 */
	int cvFindHomography(CvMat src_points, CvMat dst_points, CvMat homography, int method, double ransacReprojThreshold, CvMat mask);
	/**
	 * Computes RQ decomposition for 3x3 matrices<br>
	 * Original signature : <code>void cvRQDecomp3x3(const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvPoint3D64f*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5368</i>
	 */
	void cvRQDecomp3x3(CvMat matrixM, CvMat matrixR, CvMat matrixQ, CvMat matrixQx, CvMat matrixQy, CvMat matrixQz, CvPoint3D64f eulerAngles);
	/**
	 * Computes projection matrix decomposition<br>
	 * Original signature : <code>void cvDecomposeProjectionMatrix(const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvPoint3D64f*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5373</i>
	 */
	void cvDecomposeProjectionMatrix(CvMat projMatr, CvMat calibMatr, CvMat rotMatr, CvMat posVect, CvMat rotMatrX, CvMat rotMatrY, CvMat rotMatrZ, CvPoint3D64f eulerAngles);
	/**
	 * Computes d(AB)/dA and d(AB)/dB<br>
	 * Original signature : <code>void cvCalcMatMulDeriv(const CvMat*, const CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5378</i>
	 */
	void cvCalcMatMulDeriv(CvMat A, CvMat B, CvMat dABdA, CvMat dABdB);
	/**
	 * Computes r3 = rodrigues(rodrigues(r2)*rodrigues(r1)),<br>
	 * t3 = rodrigues(r2)*t1 + t2 and the respective derivatives<br>
	 * Original signature : <code>void cvComposeRT(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5384</i>
	 */
	void cvComposeRT(CvMat _rvec1, CvMat _tvec1, CvMat _rvec2, CvMat _tvec2, CvMat _rvec3, CvMat _tvec3, CvMat dr3dr1, CvMat dr3dt1, CvMat dr3dr2, CvMat dr3dt2, CvMat dt3dr1, CvMat dt3dt1, CvMat dt3dr2, CvMat dt3dt2);
	/**
	 * Projects object points to the view plane using<br>
	 * the specified extrinsic and intrinsic camera parameters<br>
	 * Original signature : <code>void cvProjectPoints2(const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, double)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5390</i>
	 */
	void cvProjectPoints2(CvMat object_points, CvMat rotation_vector, CvMat translation_vector, CvMat camera_matrix, CvMat distortion_coeffs, CvMat image_points, CvMat dpdrot, CvMat dpdt, CvMat dpdf, CvMat dpdc, CvMat dpddist, double aspect_ratio);
	/**
	 * Finds extrinsic camera parameters from<br>
	 * a few known corresponding point pairs and intrinsic parameters<br>
	 * Original signature : <code>void cvFindExtrinsicCameraParams2(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5396</i>
	 */
	void cvFindExtrinsicCameraParams2(CvMat object_points, CvMat image_points, CvMat camera_matrix, CvMat distortion_coeffs, CvMat rotation_vector, CvMat translation_vector, int use_extrinsic_guess);
	/**
	 * Computes initial estimate of the intrinsic camera parameters<br>
	 * in case of planar calibration target (e.g. chessboard)<br>
	 * Original signature : <code>void cvInitIntrinsicParams2D(const CvMat*, const CvMat*, const CvMat*, CvSize, CvMat*, double)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5402</i>
	 */
	void cvInitIntrinsicParams2D(CvMat object_points, CvMat image_points, CvMat npoints, sj.opencv.jna.cxcore.CvSize.ByValue image_size, CvMat camera_matrix, double aspect_ratio);
	/**
	 * 0 if there is no chessboard, -1 in case of error<br>
	 * Original signature : <code>int cvCheckChessboard(IplImage*, CvSize)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5407</i>
	 */
	int cvCheckChessboard(JNAIplImage src, sj.opencv.jna.cxcore.CvSize.ByValue size);
	/**
	 * Detects corners on a chessboard calibration pattern<br>
	 * Original signature : <code>int cvFindChessboardCorners(const void*, CvSize, CvPoint2D32f*, int*, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5412</i><br>
	 * @deprecated use the safer methods {@link #cvFindChessboardCorners(com.sun.jna.Pointer, sj.opencv.jna.cxcore.CvSize.ByValue, sj.opencv.jna.cxcore.CvPoint2D32f, java.nio.IntBuffer, int)} and {@link #cvFindChessboardCorners(com.sun.jna.Pointer, sj.opencv.jna.cxcore.CvSize.ByValue, sj.opencv.jna.cxcore.CvPoint2D32f, com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Deprecated
	int cvFindChessboardCorners(Pointer image, sj.opencv.jna.cxcore.CvSize.ByValue pattern_size, CvPoint2D32f corners, IntByReference corner_count, int flags);
	/**
	 * Detects corners on a chessboard calibration pattern<br>
	 * Original signature : <code>int cvFindChessboardCorners(const void*, CvSize, CvPoint2D32f*, int*, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5412</i>
	 */
	int cvFindChessboardCorners(Pointer image, sj.opencv.jna.cxcore.CvSize.ByValue pattern_size, CvPoint2D32f corners, IntBuffer corner_count, int flags);
	/**
	 * Draws individual chessboard corners or the whole chessboard detected<br>
	 * Original signature : <code>void cvDrawChessboardCorners(CvArr*, CvSize, CvPoint2D32f*, int, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5417</i>
	 */
	void cvDrawChessboardCorners(CvArr image, sj.opencv.jna.cxcore.CvSize.ByValue pattern_size, CvPoint2D32f corners, int count, int pattern_was_found);
	/**
	 * Finds intrinsic and extrinsic camera parameters<br>
	 * from a few views of known calibration pattern<br>
	 * Original signature : <code>double cvCalibrateCamera2(const CvMat*, const CvMat*, const CvMat*, CvSize, CvMat*, CvMat*, CvMat*, CvMat*, int, CvTermCriteria)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5423</i>
	 */
	double cvCalibrateCamera2(CvMat object_points, CvMat image_points, CvMat point_counts, sj.opencv.jna.cxcore.CvSize.ByValue image_size, CvMat camera_matrix, CvMat distortion_coeffs, CvMat rotation_vectors, CvMat translation_vectors, int flags, sj.opencv.jna.cxcore.CvTermCriteria.ByValue term_crit);
	/**
	 * Computes various useful characteristics of the camera from the data computed by<br>
	 * cvCalibrateCamera2<br>
	 * Original signature : <code>void cvCalibrationMatrixValues(const CvMat*, CvSize, double, double, double*, double*, double*, CvPoint2D64f*, double*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5429</i><br>
	 * @deprecated use the safer methods {@link #cvCalibrationMatrixValues(sj.opencv.jna.cxcore.CvMat, sj.opencv.jna.cxcore.CvSize.ByValue, double, double, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.DoubleBuffer, sj.opencv.jna.cxcore.CvPoint2D64f, java.nio.DoubleBuffer)} and {@link #cvCalibrationMatrixValues(sj.opencv.jna.cxcore.CvMat, sj.opencv.jna.cxcore.CvSize.ByValue, double, double, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, sj.opencv.jna.cxcore.CvPoint2D64f, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated
	void cvCalibrationMatrixValues(CvMat camera_matrix, sj.opencv.jna.cxcore.CvSize.ByValue image_size, double aperture_width, double aperture_height, DoubleByReference fovx, DoubleByReference fovy, DoubleByReference focal_length, CvPoint2D64f principal_point, DoubleByReference pixel_aspect_ratio);
	/**
	 * Computes various useful characteristics of the camera from the data computed by<br>
	 * cvCalibrateCamera2<br>
	 * Original signature : <code>void cvCalibrationMatrixValues(const CvMat*, CvSize, double, double, double*, double*, double*, CvPoint2D64f*, double*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5429</i>
	 */
	void cvCalibrationMatrixValues(CvMat camera_matrix, sj.opencv.jna.cxcore.CvSize.ByValue image_size, double aperture_width, double aperture_height, DoubleBuffer fovx, DoubleBuffer fovy, DoubleBuffer focal_length, CvPoint2D64f principal_point, DoubleBuffer pixel_aspect_ratio);
	/**
	 * Computes the transformation from one camera coordinate system to another one<br>
	 * from a few correspondent views of the same calibration target. Optionally, calibrates<br>
	 * both cameras<br>
	 * Original signature : <code>double cvStereoCalibrate(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvSize, CvMat*, CvMat*, CvMat*, CvMat*, CvTermCriteria, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5436</i>
	 */
	double cvStereoCalibrate(CvMat object_points, CvMat image_points1, CvMat image_points2, CvMat npoints, CvMat camera_matrix1, CvMat dist_coeffs1, CvMat camera_matrix2, CvMat dist_coeffs2, sj.opencv.jna.cxcore.CvSize.ByValue image_size, CvMat R, CvMat T, CvMat E, CvMat F, sj.opencv.jna.cxcore.CvTermCriteria.ByValue term_crit, int flags);
	/**
	 * Computes 3D rotations (+ optional shift) for each camera coordinate system to make both<br>
	 * views parallel (=> to make all the epipolar lines horizontal or vertical)<br>
	 * Original signature : <code>void cvStereoRectify(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvSize, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, int, double, CvSize, CvRect*, CvRect*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5442</i>
	 */
	void cvStereoRectify(CvMat camera_matrix1, CvMat camera_matrix2, CvMat dist_coeffs1, CvMat dist_coeffs2, sj.opencv.jna.cxcore.CvSize.ByValue image_size, CvMat R, CvMat T, CvMat R1, CvMat R2, CvMat P1, CvMat P2, CvMat Q, int flags, double alpha, sj.opencv.jna.cxcore.CvSize.ByValue new_image_size, CvRect valid_pix_ROI1, CvRect valid_pix_ROI2);
	/**
	 * Computes rectification transformations for uncalibrated pair of images using a set<br>
	 * of point correspondences<br>
	 * Original signature : <code>int cvStereoRectifyUncalibrated(const CvMat*, const CvMat*, const CvMat*, CvSize, CvMat*, CvMat*, double)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5448</i>
	 */
	int cvStereoRectifyUncalibrated(CvMat points1, CvMat points2, CvMat F, sj.opencv.jna.cxcore.CvSize.ByValue img_size, CvMat H1, CvMat H2, double threshold);
	/**
	 * Original signature : <code>CvStereoBMState* cvCreateStereoBMState(int, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5491</i>
	 */
	CvStereoBMState cvCreateStereoBMState(int preset, int numberOfDisparities);
	/**
	 * Original signature : <code>void cvReleaseStereoBMState(CvStereoBMState**)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5493</i><br>
	 * @deprecated use the safer method {@link #cvReleaseStereoBMState(sj.opencv.jna.calib3d.CvStereoBMState.ByReference[])} instead
	 */
	@Deprecated
	void cvReleaseStereoBMState(PointerByReference state);
	/**
	 * Original signature : <code>void cvReleaseStereoBMState(CvStereoBMState**)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5493</i>
	 */
	void cvReleaseStereoBMState(CvStereoBMState.ByReference state[]);
	/**
	 * Original signature : <code>void cvFindStereoCorrespondenceBM(const CvArr*, const CvArr*, CvArr*, CvStereoBMState*)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5495</i>
	 */
	void cvFindStereoCorrespondenceBM(CvArr left, CvArr right, CvArr disparity, CvStereoBMState state);
	/**
	 * Original signature : <code>CvRect cvGetValidDisparityROI(CvRect, CvRect, int, int, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5497</i>
	 */
	CvRect.ByValue cvGetValidDisparityROI(CvRect.ByValue roi1, CvRect.ByValue roi2, int minDisparity, int numberOfDisparities, int SADWindowSize);
	/**
	 * Original signature : <code>void cvValidateDisparity(CvArr*, const CvArr*, int, int, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5499</i>
	 */
	void cvValidateDisparity(CvArr disparity, CvArr cost, int minDisparity, int numberOfDisparities, int disp12MaxDiff);
	/**
	 * Reprojects the computed disparity image to the 3D space using the specified 4x4 matrix<br>
	 * Original signature : <code>void cvReprojectImageTo3D(const CvArr*, CvArr*, const CvMat*, int)</code><br>
	 * <i>native declaration : modules/calib3d/include/opencv2/calib3d/calib3d.hpp:5504</i>
	 */
	void cvReprojectImageTo3D(CvArr disparityImage, CvArr _3dImage, CvMat Q, int handleMissingValues);
	public static class CvPOSITObject extends PointerType {
		public CvPOSITObject(Pointer address) {
			super(address);
		}
		public CvPOSITObject() {
			super();
		}
	};
}
