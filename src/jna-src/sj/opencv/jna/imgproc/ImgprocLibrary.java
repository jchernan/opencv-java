/* Description and License
 * A Java library that wraps the functionality of the native image 
 * processing library OpenCV
 *
 * (c) Sigurdur Orn Adalgeirsson (siggi@alum.mit.edu)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA  02111-1307  USA
 */
 
package sj.opencv.jna.imgproc;
import com.sun.jna.Library;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.FloatByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import sj.opencv.jna.cxcore.CvChain;
import sj.opencv.jna.cxcore.CvContour;
import sj.opencv.jna.cxcore.CvHistogram;
import sj.opencv.jna.cxcore.CvMat;
import sj.opencv.jna.cxcore.CvMemStorage;
import sj.opencv.jna.cxcore.CvPoint2D32f;
import sj.opencv.jna.cxcore.CvRect;
import sj.opencv.jna.cxcore.CvSeq;
import sj.opencv.jna.cxcore.CvSeqBlock;
import sj.opencv.jna.cxcore.CvSize;
import sj.opencv.jna.cxcore.CxcoreLibrary.CvDistanceFunction;
import sj.opencv.jna.cxcore.IplConvKernel;
import sj.opencv.jna.cxcore.JNAIplImage;
import sj.opencv.jna.highgui.HighguiLibrary.CvArr;
/**
 * JNA Wrapper for library <b>imgproc</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface ImgprocLibrary extends Library {
	public static final int CV_BLUR_NO_SCALE = (int)0;
	public static final int CV_BLUR = (int)1;
	public static final int CV_GAUSSIAN = (int)2;
	public static final int CV_MEDIAN = (int)3;
	public static final int CV_BILATERAL = (int)4;
	public static final int CV_GAUSSIAN_5x5 = (int)7;
	public static final int CV_SCHARR = (int)-1;
	public static final int CV_MAX_SOBEL_KSIZE = (int)7;
	public static final int CV_BGR2BGRA = (int)0;
	public static final int CV_RGB2RGBA = (int)ImgprocLibrary.CV_BGR2BGRA;
	public static final int CV_BGRA2BGR = (int)1;
	public static final int CV_RGBA2RGB = (int)ImgprocLibrary.CV_BGRA2BGR;
	public static final int CV_BGR2RGBA = (int)2;
	public static final int CV_RGB2BGRA = (int)ImgprocLibrary.CV_BGR2RGBA;
	public static final int CV_RGBA2BGR = (int)3;
	public static final int CV_BGRA2RGB = (int)ImgprocLibrary.CV_RGBA2BGR;
	public static final int CV_BGR2RGB = (int)4;
	public static final int CV_RGB2BGR = (int)ImgprocLibrary.CV_BGR2RGB;
	public static final int CV_BGRA2RGBA = (int)5;
	public static final int CV_RGBA2BGRA = (int)ImgprocLibrary.CV_BGRA2RGBA;
	public static final int CV_BGR2GRAY = (int)6;
	public static final int CV_RGB2GRAY = (int)7;
	public static final int CV_GRAY2BGR = (int)8;
	public static final int CV_GRAY2RGB = (int)ImgprocLibrary.CV_GRAY2BGR;
	public static final int CV_GRAY2BGRA = (int)9;
	public static final int CV_GRAY2RGBA = (int)ImgprocLibrary.CV_GRAY2BGRA;
	public static final int CV_BGRA2GRAY = (int)10;
	public static final int CV_RGBA2GRAY = (int)11;
	public static final int CV_BGR2BGR565 = (int)12;
	public static final int CV_RGB2BGR565 = (int)13;
	public static final int CV_BGR5652BGR = (int)14;
	public static final int CV_BGR5652RGB = (int)15;
	public static final int CV_BGRA2BGR565 = (int)16;
	public static final int CV_RGBA2BGR565 = (int)17;
	public static final int CV_BGR5652BGRA = (int)18;
	public static final int CV_BGR5652RGBA = (int)19;
	public static final int CV_GRAY2BGR565 = (int)20;
	public static final int CV_BGR5652GRAY = (int)21;
	public static final int CV_BGR2BGR555 = (int)22;
	public static final int CV_RGB2BGR555 = (int)23;
	public static final int CV_BGR5552BGR = (int)24;
	public static final int CV_BGR5552RGB = (int)25;
	public static final int CV_BGRA2BGR555 = (int)26;
	public static final int CV_RGBA2BGR555 = (int)27;
	public static final int CV_BGR5552BGRA = (int)28;
	public static final int CV_BGR5552RGBA = (int)29;
	public static final int CV_GRAY2BGR555 = (int)30;
	public static final int CV_BGR5552GRAY = (int)31;
	public static final int CV_BGR2XYZ = (int)32;
	public static final int CV_RGB2XYZ = (int)33;
	public static final int CV_XYZ2BGR = (int)34;
	public static final int CV_XYZ2RGB = (int)35;
	public static final int CV_BGR2YCrCb = (int)36;
	public static final int CV_RGB2YCrCb = (int)37;
	public static final int CV_YCrCb2BGR = (int)38;
	public static final int CV_YCrCb2RGB = (int)39;
	public static final int CV_BGR2HSV = (int)40;
	public static final int CV_RGB2HSV = (int)41;
	public static final int CV_BGR2Lab = (int)44;
	public static final int CV_RGB2Lab = (int)45;
	public static final int CV_BayerBG2BGR = (int)46;
	public static final int CV_BayerGB2BGR = (int)47;
	public static final int CV_BayerRG2BGR = (int)48;
	public static final int CV_BayerGR2BGR = (int)49;
	public static final int CV_BayerBG2RGB = (int)ImgprocLibrary.CV_BayerRG2BGR;
	public static final int CV_BayerGB2RGB = (int)ImgprocLibrary.CV_BayerGR2BGR;
	public static final int CV_BayerRG2RGB = (int)ImgprocLibrary.CV_BayerBG2BGR;
	public static final int CV_BayerGR2RGB = (int)ImgprocLibrary.CV_BayerGB2BGR;
	public static final int CV_BGR2Luv = (int)50;
	public static final int CV_RGB2Luv = (int)51;
	public static final int CV_BGR2HLS = (int)52;
	public static final int CV_RGB2HLS = (int)53;
	public static final int CV_HSV2BGR = (int)54;
	public static final int CV_HSV2RGB = (int)55;
	public static final int CV_Lab2BGR = (int)56;
	public static final int CV_Lab2RGB = (int)57;
	public static final int CV_Luv2BGR = (int)58;
	public static final int CV_Luv2RGB = (int)59;
	public static final int CV_HLS2BGR = (int)60;
	public static final int CV_HLS2RGB = (int)61;
	public static final int CV_BayerBG2BGR_VNG = (int)62;
	public static final int CV_BayerGB2BGR_VNG = (int)63;
	public static final int CV_BayerRG2BGR_VNG = (int)64;
	public static final int CV_BayerGR2BGR_VNG = (int)65;
	public static final int CV_BayerBG2RGB_VNG = (int)ImgprocLibrary.CV_BayerRG2BGR_VNG;
	public static final int CV_BayerGB2RGB_VNG = (int)ImgprocLibrary.CV_BayerGR2BGR_VNG;
	public static final int CV_BayerRG2RGB_VNG = (int)ImgprocLibrary.CV_BayerBG2BGR_VNG;
	public static final int CV_BayerGR2RGB_VNG = (int)ImgprocLibrary.CV_BayerGB2BGR_VNG;
	public static final int CV_BGR2HSV_FULL = (int)66;
	public static final int CV_RGB2HSV_FULL = (int)67;
	public static final int CV_BGR2HLS_FULL = (int)68;
	public static final int CV_RGB2HLS_FULL = (int)69;
	public static final int CV_HSV2BGR_FULL = (int)70;
	public static final int CV_HSV2RGB_FULL = (int)71;
	public static final int CV_HLS2BGR_FULL = (int)72;
	public static final int CV_HLS2RGB_FULL = (int)73;
	public static final int CV_LBGR2Lab = (int)74;
	public static final int CV_LRGB2Lab = (int)75;
	public static final int CV_LBGR2Luv = (int)76;
	public static final int CV_LRGB2Luv = (int)77;
	public static final int CV_Lab2LBGR = (int)78;
	public static final int CV_Lab2LRGB = (int)79;
	public static final int CV_Luv2LBGR = (int)80;
	public static final int CV_Luv2LRGB = (int)81;
	public static final int CV_BGR2YUV = (int)82;
	public static final int CV_RGB2YUV = (int)83;
	public static final int CV_YUV2BGR = (int)84;
	public static final int CV_YUV2RGB = (int)85;
	public static final int CV_BayerBG2GRAY = (int)86;
	public static final int CV_BayerGB2GRAY = (int)87;
	public static final int CV_BayerRG2GRAY = (int)88;
	public static final int CV_BayerGR2GRAY = (int)89;
	/// YUV 4:2:0 formats family
	public static final int CV_YUV2RGB_NV12 = (int)90;
	public static final int CV_YUV2BGR_NV12 = (int)91;
	public static final int CV_YUV2RGB_NV21 = (int)92;
	public static final int CV_YUV2BGR_NV21 = (int)93;
	public static final int CV_YUV420sp2RGB = (int)ImgprocLibrary.CV_YUV2RGB_NV21;
	public static final int CV_YUV420sp2BGR = (int)ImgprocLibrary.CV_YUV2BGR_NV21;
	public static final int CV_YUV2RGBA_NV12 = (int)94;
	public static final int CV_YUV2BGRA_NV12 = (int)95;
	public static final int CV_YUV2RGBA_NV21 = (int)96;
	public static final int CV_YUV2BGRA_NV21 = (int)97;
	public static final int CV_YUV420sp2RGBA = (int)ImgprocLibrary.CV_YUV2RGBA_NV21;
	public static final int CV_YUV420sp2BGRA = (int)ImgprocLibrary.CV_YUV2BGRA_NV21;
	public static final int CV_YUV2RGB_YV12 = (int)98;
	public static final int CV_YUV2BGR_YV12 = (int)99;
	public static final int CV_YUV2RGB_IYUV = (int)100;
	public static final int CV_YUV2BGR_IYUV = (int)101;
	public static final int CV_YUV2RGB_I420 = (int)ImgprocLibrary.CV_YUV2RGB_IYUV;
	public static final int CV_YUV2BGR_I420 = (int)ImgprocLibrary.CV_YUV2BGR_IYUV;
	public static final int CV_YUV420p2RGB = (int)ImgprocLibrary.CV_YUV2RGB_YV12;
	public static final int CV_YUV420p2BGR = (int)ImgprocLibrary.CV_YUV2BGR_YV12;
	public static final int CV_YUV2RGBA_YV12 = (int)102;
	public static final int CV_YUV2BGRA_YV12 = (int)103;
	public static final int CV_YUV2RGBA_IYUV = (int)104;
	public static final int CV_YUV2BGRA_IYUV = (int)105;
	public static final int CV_YUV2RGBA_I420 = (int)ImgprocLibrary.CV_YUV2RGBA_IYUV;
	public static final int CV_YUV2BGRA_I420 = (int)ImgprocLibrary.CV_YUV2BGRA_IYUV;
	public static final int CV_YUV420p2RGBA = (int)ImgprocLibrary.CV_YUV2RGBA_YV12;
	public static final int CV_YUV420p2BGRA = (int)ImgprocLibrary.CV_YUV2BGRA_YV12;
	public static final int CV_YUV2GRAY_420 = (int)106;
	public static final int CV_YUV2GRAY_NV21 = (int)ImgprocLibrary.CV_YUV2GRAY_420;
	public static final int CV_YUV2GRAY_NV12 = (int)ImgprocLibrary.CV_YUV2GRAY_420;
	public static final int CV_YUV2GRAY_YV12 = (int)ImgprocLibrary.CV_YUV2GRAY_420;
	public static final int CV_YUV2GRAY_IYUV = (int)ImgprocLibrary.CV_YUV2GRAY_420;
	public static final int CV_YUV2GRAY_I420 = (int)ImgprocLibrary.CV_YUV2GRAY_420;
	public static final int CV_YUV420sp2GRAY = (int)ImgprocLibrary.CV_YUV2GRAY_420;
	public static final int CV_YUV420p2GRAY = (int)ImgprocLibrary.CV_YUV2GRAY_420;
	/// YUV 4:2:2 formats family
	public static final int CV_YUV2RGB_UYVY = (int)107;
	public static final int CV_YUV2BGR_UYVY = (int)108;
	/// CV_YUV2BGR_VYUY = 110,
	public static final int CV_YUV2RGB_Y422 = (int)ImgprocLibrary.CV_YUV2RGB_UYVY;
	public static final int CV_YUV2BGR_Y422 = (int)ImgprocLibrary.CV_YUV2BGR_UYVY;
	public static final int CV_YUV2RGB_UYNV = (int)ImgprocLibrary.CV_YUV2RGB_UYVY;
	public static final int CV_YUV2BGR_UYNV = (int)ImgprocLibrary.CV_YUV2BGR_UYVY;
	public static final int CV_YUV2RGBA_UYVY = (int)111;
	public static final int CV_YUV2BGRA_UYVY = (int)112;
	/// CV_YUV2BGRA_VYUY = 114,
	public static final int CV_YUV2RGBA_Y422 = (int)ImgprocLibrary.CV_YUV2RGBA_UYVY;
	public static final int CV_YUV2BGRA_Y422 = (int)ImgprocLibrary.CV_YUV2BGRA_UYVY;
	public static final int CV_YUV2RGBA_UYNV = (int)ImgprocLibrary.CV_YUV2RGBA_UYVY;
	public static final int CV_YUV2BGRA_UYNV = (int)ImgprocLibrary.CV_YUV2BGRA_UYVY;
	public static final int CV_YUV2RGB_YUY2 = (int)115;
	public static final int CV_YUV2BGR_YUY2 = (int)116;
	public static final int CV_YUV2RGB_YVYU = (int)117;
	public static final int CV_YUV2BGR_YVYU = (int)118;
	public static final int CV_YUV2RGB_YUYV = (int)ImgprocLibrary.CV_YUV2RGB_YUY2;
	public static final int CV_YUV2BGR_YUYV = (int)ImgprocLibrary.CV_YUV2BGR_YUY2;
	public static final int CV_YUV2RGB_YUNV = (int)ImgprocLibrary.CV_YUV2RGB_YUY2;
	public static final int CV_YUV2BGR_YUNV = (int)ImgprocLibrary.CV_YUV2BGR_YUY2;
	public static final int CV_YUV2RGBA_YUY2 = (int)119;
	public static final int CV_YUV2BGRA_YUY2 = (int)120;
	public static final int CV_YUV2RGBA_YVYU = (int)121;
	public static final int CV_YUV2BGRA_YVYU = (int)122;
	public static final int CV_YUV2RGBA_YUYV = (int)ImgprocLibrary.CV_YUV2RGBA_YUY2;
	public static final int CV_YUV2BGRA_YUYV = (int)ImgprocLibrary.CV_YUV2BGRA_YUY2;
	public static final int CV_YUV2RGBA_YUNV = (int)ImgprocLibrary.CV_YUV2RGBA_YUY2;
	public static final int CV_YUV2BGRA_YUNV = (int)ImgprocLibrary.CV_YUV2BGRA_YUY2;
	public static final int CV_YUV2GRAY_UYVY = (int)123;
	public static final int CV_YUV2GRAY_YUY2 = (int)124;
	/// CV_YUV2GRAY_VYUY = CV_YUV2GRAY_UYVY,
	public static final int CV_YUV2GRAY_Y422 = (int)ImgprocLibrary.CV_YUV2GRAY_UYVY;
	public static final int CV_YUV2GRAY_UYNV = (int)ImgprocLibrary.CV_YUV2GRAY_UYVY;
	public static final int CV_YUV2GRAY_YVYU = (int)ImgprocLibrary.CV_YUV2GRAY_YUY2;
	public static final int CV_YUV2GRAY_YUYV = (int)ImgprocLibrary.CV_YUV2GRAY_YUY2;
	public static final int CV_YUV2GRAY_YUNV = (int)ImgprocLibrary.CV_YUV2GRAY_YUY2;
	public static final int CV_COLORCVT_MAX = (int)125;
	public static final int CV_INTER_NN = (int)0;
	public static final int CV_INTER_LINEAR = (int)1;
	public static final int CV_INTER_CUBIC = (int)2;
	public static final int CV_INTER_AREA = (int)3;
	public static final int CV_INTER_LANCZOS4 = (int)4;
	public static final int CV_WARP_FILL_OUTLIERS = (int)8;
	public static final int CV_WARP_INVERSE_MAP = (int)16;
	public static final int CV_SHAPE_RECT = (int)0;
	public static final int CV_SHAPE_CROSS = (int)1;
	public static final int CV_SHAPE_ELLIPSE = (int)2;
	public static final int CV_SHAPE_CUSTOM = (int)100;
	public static final int CV_MOP_ERODE = (int)0;
	public static final int CV_MOP_DILATE = (int)1;
	public static final int CV_MOP_OPEN = (int)2;
	public static final int CV_MOP_CLOSE = (int)3;
	public static final int CV_MOP_GRADIENT = (int)4;
	public static final int CV_MOP_TOPHAT = (int)5;
	public static final int CV_MOP_BLACKHAT = (int)6;
	public static final int CV_TM_SQDIFF = (int)0;
	public static final int CV_TM_SQDIFF_NORMED = (int)1;
	public static final int CV_TM_CCORR = (int)2;
	public static final int CV_TM_CCORR_NORMED = (int)3;
	public static final int CV_TM_CCOEFF = (int)4;
	public static final int CV_TM_CCOEFF_NORMED = (int)5;
	public static final int CV_RETR_EXTERNAL = (int)0;
	public static final int CV_RETR_LIST = (int)1;
	public static final int CV_RETR_CCOMP = (int)2;
	public static final int CV_RETR_TREE = (int)3;
	public static final int CV_RETR_FLOODFILL = (int)4;
	public static final int CV_CHAIN_CODE = (int)0;
	public static final int CV_CHAIN_APPROX_NONE = (int)1;
	public static final int CV_CHAIN_APPROX_SIMPLE = (int)2;
	public static final int CV_CHAIN_APPROX_TC89_L1 = (int)3;
	public static final int CV_CHAIN_APPROX_TC89_KCOS = (int)4;
	public static final int CV_LINK_RUNS = (int)5;
	/**
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3952</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3952</i><br>
	 * enum values
	 */
	public static interface CvSubdiv2DPointLocation {
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3947</i>
		public static final int CV_PTLOC_ERROR = (int)-2;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3948</i>
		public static final int CV_PTLOC_OUTSIDE_RECT = (int)-1;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3949</i>
		public static final int CV_PTLOC_INSIDE = (int)0;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3950</i>
		public static final int CV_PTLOC_VERTEX = (int)1;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3951</i>
		public static final int CV_PTLOC_ON_EDGE = (int)2;
	};
	/**
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3962</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3962</i><br>
	 * enum values
	 */
	public static interface CvNextEdgeType {
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3954</i>
		public static final int CV_NEXT_AROUND_ORG = (int)0;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3955</i>
		public static final int CV_NEXT_AROUND_DST = (int)34;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3956</i>
		public static final int CV_PREV_AROUND_ORG = (int)17;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3957</i>
		public static final int CV_PREV_AROUND_DST = (int)51;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3958</i>
		public static final int CV_NEXT_AROUND_LEFT = (int)19;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3959</i>
		public static final int CV_NEXT_AROUND_RIGHT = (int)49;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3960</i>
		public static final int CV_PREV_AROUND_LEFT = (int)32;
		/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h:3961</i>
		public static final int CV_PREV_AROUND_RIGHT = (int)2;
	};
	public static final int CV_POLY_APPROX_DP = (int)0;
	public static final int CV_CONTOURS_MATCH_I1 = (int)1;
	public static final int CV_CONTOURS_MATCH_I2 = (int)2;
	public static final int CV_CONTOURS_MATCH_I3 = (int)3;
	public static final int CV_CLOCKWISE = (int)1;
	public static final int CV_COUNTER_CLOCKWISE = (int)2;
	public static final int CV_COMP_CORREL = (int)0;
	public static final int CV_COMP_CHISQR = (int)1;
	public static final int CV_COMP_INTERSECT = (int)2;
	public static final int CV_COMP_BHATTACHARYYA = (int)3;
	public static final int CV_DIST_MASK_3 = (int)3;
	public static final int CV_DIST_MASK_5 = (int)5;
	public static final int CV_DIST_MASK_PRECISE = (int)0;
	public static final int CV_DIST_LABEL_CCOMP = (int)0;
	public static final int CV_DIST_LABEL_PIXEL = (int)1;
	/// User defined distance
	public static final int CV_DIST_USER = (int)-1;
	/// distance = |x1-x2| + |y1-y2|
	public static final int CV_DIST_L1 = (int)1;
	/// the simple euclidean distance
	public static final int CV_DIST_L2 = (int)2;
	/// distance = max(|x1-x2|,|y1-y2|)
	public static final int CV_DIST_C = (int)3;
	/// L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1))
	public static final int CV_DIST_L12 = (int)4;
	/// distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998
	public static final int CV_DIST_FAIR = (int)5;
	/// distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846
	public static final int CV_DIST_WELSCH = (int)6;
	/// distance = |x|<c ? x^2/2 : c(|x|-c/2), c=1.345
	public static final int CV_DIST_HUBER = (int)7;
	/// value = value > threshold ? max_value : 0
	public static final int CV_THRESH_BINARY = (int)0;
	/// value = value > threshold ? 0 : max_value
	public static final int CV_THRESH_BINARY_INV = (int)1;
	/// value = value > threshold ? threshold : value
	public static final int CV_THRESH_TRUNC = (int)2;
	/// value = value > threshold ? value : 0
	public static final int CV_THRESH_TOZERO = (int)3;
	/// value = value > threshold ? 0 : value
	public static final int CV_THRESH_TOZERO_INV = (int)4;
	public static final int CV_THRESH_MASK = (int)7;
	/**
	 * use Otsu algorithm to choose the optimal threshold value;<br>
	 * combine the flag with one of the above CV_THRESH_* values
	 */
	public static final int CV_THRESH_OTSU = (int)8;
	public static final int CV_ADAPTIVE_THRESH_MEAN_C = (int)0;
	public static final int CV_ADAPTIVE_THRESH_GAUSSIAN_C = (int)1;
	public static final int CV_FLOODFILL_FIXED_RANGE = (int)(1 << 16);
	public static final int CV_FLOODFILL_MASK_ONLY = (int)(1 << 17);
	public static final int CV_CANNY_L2_GRADIENT = (int)(1 << 31);
	public static final int CV_HOUGH_STANDARD = (int)0;
	public static final int CV_HOUGH_PROBABILISTIC = (int)1;
	public static final int CV_HOUGH_MULTI_SCALE = (int)2;
	public static final int CV_HOUGH_GRADIENT = (int)3;
	/// <i>native declaration : modules/imgproc/include/opencv2/imgproc/types_c.h</i>
	public static final int CV_SUBDIV2D_VIRTUAL_POINT_FLAG = (int)(1 << 30);
	/**
	 * Adds image to accumulator<br>
	 * Original signature : <code>void cvAcc(const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4055</i>
	 */
	void cvAcc(CvArr image, CvArr sum, CvArr mask);
	/**
	 * Adds squared image to accumulator<br>
	 * Original signature : <code>void cvSquareAcc(const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4060</i>
	 */
	void cvSquareAcc(CvArr image, CvArr sqsum, CvArr mask);
	/**
	 * Adds a product of two images to accumulator<br>
	 * Original signature : <code>void cvMultiplyAcc(const CvArr*, const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4065</i>
	 */
	void cvMultiplyAcc(CvArr image1, CvArr image2, CvArr acc, CvArr mask);
	/**
	 * Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha<br>
	 * Original signature : <code>void cvRunningAvg(const CvArr*, CvArr*, double, const CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4070</i>
	 */
	void cvRunningAvg(CvArr image, CvArr acc, double alpha, CvArr mask);
	/**
	 * Copies source 2D array inside of the larger destination array and<br>
	 * makes a border of the specified type (IPL_BORDER_*) around the copied area.<br>
	 * Original signature : <code>void cvCopyMakeBorder(const CvArr*, CvArr*, CvPoint, int, CvScalar)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4076</i>
	 */
	void cvCopyMakeBorder(CvArr src, CvArr dst, sj.opencv.jna.cxcore.CvPoint.ByValue offset, int bordertype, sj.opencv.jna.cxcore.CvScalar.ByValue value);
	/**
	 * Smoothes array (removes noise)<br>
	 * Original signature : <code>void cvSmooth(const CvArr*, CvArr*, int, int, int, double, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4081</i>
	 */
	void cvSmooth(CvArr src, CvArr dst, int smoothtype, int size1, int size2, double sigma1, double sigma2);
	/**
	 * Convolves the image with the kernel<br>
	 * Original signature : <code>void cvFilter2D(const CvArr*, CvArr*, const CvMat*, CvPoint)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4086</i>
	 */
	void cvFilter2D(CvArr src, CvArr dst, CvMat kernel, sj.opencv.jna.cxcore.CvPoint.ByValue anchor);
	/**
	 * Finds integral image: SUM(X,Y) = sum(x<X,y<Y)I(x,y)<br>
	 * Original signature : <code>void cvIntegral(const CvArr*, CvArr*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4091</i>
	 */
	void cvIntegral(CvArr image, CvArr sum, CvArr sqsum, CvArr tilted_sum);
	/**
	 * Smoothes the input image with gaussian kernel and then down-samples it.<br>
	 * dst_width = floor(src_width/2)[+1],<br>
	 * dst_height = floor(src_height/2)[+1]<br>
	 * Original signature : <code>void cvPyrDown(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4098</i>
	 */
	void cvPyrDown(CvArr src, CvArr dst, int filter);
	/**
	 * Up-samples image and smoothes the result with gaussian kernel.<br>
	 * dst_width = src_width*2,<br>
	 * dst_height = src_height*2<br>
	 * Original signature : <code>void cvPyrUp(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4105</i>
	 */
	void cvPyrUp(CvArr src, CvArr dst, int filter);
	/**
	 * Builds pyramid for an image<br>
	 * Original signature : <code>CvMat** cvCreatePyramid(const CvArr*, int, double, const CvSize*, CvArr*, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4110</i>
	 */
	CvMat.ByReference[] cvCreatePyramid(CvArr img, int extra_layers, double rate, CvSize layer_sizes, CvArr bufarr, int calc, int filter);
	/**
	 * Releases pyramid<br>
	 * Original signature : <code>void cvReleasePyramid(CvMat***, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4115</i>
	 */
	void cvReleasePyramid(PointerByReference pyramid, int extra_layers);
	/**
	 * Filters image using meanshift algorithm<br>
	 * Original signature : <code>void cvPyrMeanShiftFiltering(const CvArr*, CvArr*, double, double, int, CvTermCriteria)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4120</i>
	 */
	void cvPyrMeanShiftFiltering(CvArr src, CvArr dst, double sp, double sr, int max_level, sj.opencv.jna.cxcore.CvTermCriteria.ByValue termcrit);
	/**
	 * Segments image using seed "markers"<br>
	 * Original signature : <code>void cvWatershed(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4125</i>
	 */
	void cvWatershed(CvArr image, CvArr markers);
	/**
	 * Calculates an image derivative using generalized Sobel<br>
	 * (aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator.<br>
	 * Scharr can be used only for the first dx or dy derivative<br>
	 * Original signature : <code>void cvSobel(const CvArr*, CvArr*, int, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4132</i>
	 */
	void cvSobel(CvArr src, CvArr dst, int xorder, int yorder, int aperture_size);
	/**
	 * Calculates the image Laplacian: (d2/dx + d2/dy)I<br>
	 * Original signature : <code>void cvLaplace(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4137</i>
	 */
	void cvLaplace(CvArr src, CvArr dst, int aperture_size);
	/**
	 * Converts input array pixels from one color space to another<br>
	 * Original signature : <code>void cvCvtColor(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4142</i>
	 */
	void cvCvtColor(CvArr src, CvArr dst, int code);
	/**
	 * Resizes image (input array is resized to fit the destination array)<br>
	 * Original signature : <code>void cvResize(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4147</i>
	 */
	void cvResize(CvArr src, CvArr dst, int interpolation);
	/**
	 * Warps image with affine transform<br>
	 * Original signature : <code>void cvWarpAffine(const CvArr*, CvArr*, const CvMat*, int, CvScalar)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4152</i>
	 */
	void cvWarpAffine(CvArr src, CvArr dst, CvMat map_matrix, int flags, sj.opencv.jna.cxcore.CvScalar.ByValue fillval);
	/**
	 * Computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2)<br>
	 * Original signature : <code>CvMat* cvGetAffineTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4157</i>
	 */
	CvMat cvGetAffineTransform(CvPoint2D32f src, CvPoint2D32f dst, CvMat map_matrix);
	/**
	 * Computes rotation_matrix matrix<br>
	 * Original signature : <code>CvMat* cv2DRotationMatrix(CvPoint2D32f, double, double, CvMat*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4162</i>
	 */
	CvMat cv2DRotationMatrix(CvPoint2D32f.ByValue center, double angle, double scale, CvMat map_matrix);
	/**
	 * Warps image with perspective (projective) transform<br>
	 * Original signature : <code>void cvWarpPerspective(const CvArr*, CvArr*, const CvMat*, int, CvScalar)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4167</i>
	 */
	void cvWarpPerspective(CvArr src, CvArr dst, CvMat map_matrix, int flags, sj.opencv.jna.cxcore.CvScalar.ByValue fillval);
	/**
	 * Computes perspective transform matrix for mapping src[i] to dst[i] (i=0,1,2,3)<br>
	 * Original signature : <code>CvMat* cvGetPerspectiveTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4172</i>
	 */
	CvMat cvGetPerspectiveTransform(CvPoint2D32f src, CvPoint2D32f dst, CvMat map_matrix);
	/**
	 * Performs generic geometric transformation using the specified coordinate maps<br>
	 * Original signature : <code>void cvRemap(const CvArr*, CvArr*, const CvArr*, const CvArr*, int, CvScalar)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4177</i>
	 */
	void cvRemap(CvArr src, CvArr dst, CvArr mapx, CvArr mapy, int flags, sj.opencv.jna.cxcore.CvScalar.ByValue fillval);
	/**
	 * Converts mapx & mapy from floating-point to integer formats for cvRemap<br>
	 * Original signature : <code>void cvConvertMaps(const CvArr*, const CvArr*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4182</i>
	 */
	void cvConvertMaps(CvArr mapx, CvArr mapy, CvArr mapxy, CvArr mapalpha);
	/**
	 * Performs forward or inverse log-polar image transform<br>
	 * Original signature : <code>void cvLogPolar(const CvArr*, CvArr*, CvPoint2D32f, double, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4187</i>
	 */
	void cvLogPolar(CvArr src, CvArr dst, CvPoint2D32f.ByValue center, double M, int flags);
	/**
	 * Performs forward or inverse linear-polar image transform<br>
	 * Original signature : <code>void cvLinearPolar(const CvArr*, CvArr*, CvPoint2D32f, double, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4192</i>
	 */
	void cvLinearPolar(CvArr src, CvArr dst, CvPoint2D32f.ByValue center, double maxRadius, int flags);
	/**
	 * Transforms the input image to compensate lens distortion<br>
	 * Original signature : <code>void cvUndistort2(const CvArr*, CvArr*, const CvMat*, const CvMat*, const CvMat*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4197</i>
	 */
	void cvUndistort2(CvArr src, CvArr dst, CvMat camera_matrix, CvMat distortion_coeffs, CvMat new_camera_matrix);
	/**
	 * Computes transformation map from intrinsic camera parameters<br>
	 * that can used by cvRemap<br>
	 * Original signature : <code>void cvInitUndistortMap(const CvMat*, const CvMat*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4203</i>
	 */
	void cvInitUndistortMap(CvMat camera_matrix, CvMat distortion_coeffs, CvArr mapx, CvArr mapy);
	/**
	 * Computes undistortion+rectification map for a head of stereo camera<br>
	 * Original signature : <code>void cvInitUndistortRectifyMap(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4208</i>
	 */
	void cvInitUndistortRectifyMap(CvMat camera_matrix, CvMat dist_coeffs, CvMat R, CvMat new_camera_matrix, CvArr mapx, CvArr mapy);
	/**
	 * Computes the original (undistorted) feature coordinates<br>
	 * from the observed (distorted) coordinates<br>
	 * Original signature : <code>void cvUndistortPoints(const CvMat*, CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4214</i>
	 */
	void cvUndistortPoints(CvMat src, CvMat dst, CvMat camera_matrix, CvMat dist_coeffs, CvMat R, CvMat P);
	/**
	 * creates structuring element used for morphological operations<br>
	 * Original signature : <code>IplConvKernel* cvCreateStructuringElementEx(int, int, int, int, int, int*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4219</i><br>
	 * @deprecated use the safer methods {@link #cvCreateStructuringElementEx(int, int, int, int, int, java.nio.IntBuffer)} and {@link #cvCreateStructuringElementEx(int, int, int, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	IplConvKernel cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, IntByReference values);
	/**
	 * creates structuring element used for morphological operations<br>
	 * Original signature : <code>IplConvKernel* cvCreateStructuringElementEx(int, int, int, int, int, int*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4219</i>
	 */
	IplConvKernel cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, IntBuffer values);
	/**
	 * releases structuring element<br>
	 * Original signature : <code>void cvReleaseStructuringElement(IplConvKernel**)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4224</i><br>
	 * @deprecated use the safer method {@link #cvReleaseStructuringElement(sj.opencv.jna.cxcore.IplConvKernel.ByReference[])} instead
	 */
	@Deprecated
	void cvReleaseStructuringElement(PointerByReference element);
	/**
	 * releases structuring element<br>
	 * Original signature : <code>void cvReleaseStructuringElement(IplConvKernel**)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4224</i>
	 */
	void cvReleaseStructuringElement(IplConvKernel.ByReference element[]);
	/**
	 * erodes input image (applies minimum filter) one or more times.<br>
	 * If element pointer is NULL, 3x3 rectangular element is used<br>
	 * Original signature : <code>void cvErode(const CvArr*, CvArr*, IplConvKernel*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4230</i>
	 */
	void cvErode(CvArr src, CvArr dst, IplConvKernel element, int iterations);
	/**
	 * dilates input image (applies maximum filter) one or more times.<br>
	 * If element pointer is NULL, 3x3 rectangular element is used<br>
	 * Original signature : <code>void cvDilate(const CvArr*, CvArr*, IplConvKernel*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4236</i>
	 */
	void cvDilate(CvArr src, CvArr dst, IplConvKernel element, int iterations);
	/**
	 * Performs complex morphological transformation<br>
	 * Original signature : <code>void cvMorphologyEx(const CvArr*, CvArr*, CvArr*, IplConvKernel*, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4241</i>
	 */
	void cvMorphologyEx(CvArr src, CvArr dst, CvArr temp, IplConvKernel element, int operation, int iterations);
	/**
	 * Calculates all spatial and central moments up to the 3rd order<br>
	 * Original signature : <code>void cvMoments(const CvArr*, CvMoments*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4246</i>
	 */
	void cvMoments(CvArr arr, CvMoments moments, int binary);
	/**
	 * Retrieve particular spatial, central or normalized central moments<br>
	 * Original signature : <code>double cvGetSpatialMoment(CvMoments*, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4251</i>
	 */
	double cvGetSpatialMoment(CvMoments moments, int x_order, int y_order);
	/**
	 * Original signature : <code>double cvGetCentralMoment(CvMoments*, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4253</i>
	 */
	double cvGetCentralMoment(CvMoments moments, int x_order, int y_order);
	/**
	 * Original signature : <code>double cvGetNormalizedCentralMoment(CvMoments*, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4255</i>
	 */
	double cvGetNormalizedCentralMoment(CvMoments moments, int x_order, int y_order);
	/**
	 * Calculates 7 Hu's invariants from precalculated spatial and central moments<br>
	 * Original signature : <code>void cvGetHuMoments(CvMoments*, CvHuMoments*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4260</i>
	 */
	void cvGetHuMoments(CvMoments moments, CvHuMoments hu_moments);
	/**
	 * Fetches pixels that belong to the specified line segment and stores them to the buffer.<br>
	 * Returns the number of retrieved points.<br>
	 * Original signature : <code>int cvSampleLine(const CvArr*, CvPoint, CvPoint, void*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4266</i>
	 */
	int cvSampleLine(CvArr image, sj.opencv.jna.cxcore.CvPoint.ByValue pt1, sj.opencv.jna.cxcore.CvPoint.ByValue pt2, Pointer buffer, int connectivity);
	/**
	 * Retrieves the rectangular image region with specified center from the input array.<br>
	 * dst(x,y) <- src(x + center.x - dst_width/2, y + center.y - dst_height/2).<br>
	 * Values of pixels with fractional coordinates are retrieved using bilinear interpolation<br>
	 * Original signature : <code>void cvGetRectSubPix(const CvArr*, CvArr*, CvPoint2D32f)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4273</i>
	 */
	void cvGetRectSubPix(CvArr src, CvArr dst, CvPoint2D32f.ByValue center);
	/**
	 * Retrieves quadrangle from the input array.<br>
	 * matrixarr = ( a11  a12 | b1 )   dst(x,y) <- src(A[x y]' + b)<br>
	 * ( a21  a22 | b2 )   (bilinear interpolation is used to retrieve pixels<br>
	 * with fractional coordinates)<br>
	 * Original signature : <code>void cvGetQuadrangleSubPix(const CvArr*, CvArr*, const CvMat*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4281</i>
	 */
	void cvGetQuadrangleSubPix(CvArr src, CvArr dst, CvMat map_matrix);
	/**
	 * Measures similarity between template and overlapped windows in the source image<br>
	 * and fills the resultant image with the measurements<br>
	 * Original signature : <code>void cvMatchTemplate(const CvArr*, const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4287</i>
	 */
	void cvMatchTemplate(CvArr image, CvArr templ, CvArr result, int method);
	/**
	 * Computes earth mover distance between<br>
	 * two weighted point sets (called signatures)<br>
	 * Original signature : <code>float cvCalcEMD2(const CvArr*, const CvArr*, int, CvDistanceFunction, const CvArr*, CvArr*, float*, void*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4293</i><br>
	 * @deprecated use the safer methods {@link #cvCalcEMD2(sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.highgui.HighguiLibrary.CvArr, int, sj.opencv.jna.cxcore.CxcoreLibrary.CvDistanceFunction, sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.highgui.HighguiLibrary.CvArr, java.nio.FloatBuffer, com.sun.jna.Pointer)} and {@link #cvCalcEMD2(sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.highgui.HighguiLibrary.CvArr, int, sj.opencv.jna.cxcore.CxcoreLibrary.CvDistanceFunction, sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.highgui.HighguiLibrary.CvArr, com.sun.jna.ptr.FloatByReference, com.sun.jna.Pointer)} instead
	 */
	@Deprecated
	float cvCalcEMD2(CvArr signature1, CvArr signature2, int distance_type, CvDistanceFunction distance_func, CvArr cost_matrix, CvArr flow, FloatByReference lower_bound, Pointer userdata);
	/**
	 * Computes earth mover distance between<br>
	 * two weighted point sets (called signatures)<br>
	 * Original signature : <code>float cvCalcEMD2(const CvArr*, const CvArr*, int, CvDistanceFunction, const CvArr*, CvArr*, float*, void*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4293</i>
	 */
	float cvCalcEMD2(CvArr signature1, CvArr signature2, int distance_type, CvDistanceFunction distance_func, CvArr cost_matrix, CvArr flow, FloatBuffer lower_bound, Pointer userdata);
	/**
	 * Retrieves outer and optionally inner boundaries of white (non-zero) connected<br>
	 * components in the black (zero) background<br>
	 * Original signature : <code>int cvFindContours(CvArr*, CvMemStorage*, CvSeq**, int, int, int, CvPoint)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4299</i><br>
	 * @deprecated use the safer method {@link #cvFindContours(sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.cxcore.CvMemStorage, sj.opencv.jna.cxcore.CvSeq.ByReference[], int, int, int, sj.opencv.jna.cxcore.CvPoint.ByValue)} instead
	 */
	@Deprecated
	int cvFindContours(CvArr image, CvMemStorage storage, PointerByReference first_contour, int header_size, int mode, int method, sj.opencv.jna.cxcore.CvPoint.ByValue offset);
	/**
	 * Retrieves outer and optionally inner boundaries of white (non-zero) connected<br>
	 * components in the black (zero) background<br>
	 * Original signature : <code>int cvFindContours(CvArr*, CvMemStorage*, CvSeq**, int, int, int, CvPoint)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4299</i>
	 */
	int cvFindContours(CvArr image, CvMemStorage storage, CvSeq.ByReference[] first_contour, int header_size, int mode, int method, sj.opencv.jna.cxcore.CvPoint.ByValue offset);
	/**
	 * Initalizes contour retrieving process.<br>
	 * Calls cvStartFindContours.<br>
	 * Calls cvFindNextContour until null pointer is returned<br>
	 * or some other condition becomes true.<br>
	 * Calls cvEndFindContours at the end.<br>
	 * Original signature : <code>CvContourScanner cvStartFindContours(CvArr*, CvMemStorage*, int, int, int, CvPoint)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4308</i>
	 */
	ImgprocLibrary.CvContourScanner cvStartFindContours(CvArr image, CvMemStorage storage, int header_size, int mode, int method, sj.opencv.jna.cxcore.CvPoint.ByValue offset);
	/**
	 * Retrieves next contour<br>
	 * Original signature : <code>CvSeq* cvFindNextContour(CvContourScanner)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4313</i>
	 */
	CvSeq cvFindNextContour(ImgprocLibrary.CvContourScanner scanner);
	/**
	 * Substitutes the last retrieved contour with the new one<br>
	 * (if the substitutor is null, the last retrieved contour is removed from the tree)<br>
	 * Original signature : <code>void cvSubstituteContour(CvContourScanner, CvSeq*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4319</i>
	 */
	void cvSubstituteContour(ImgprocLibrary.CvContourScanner scanner, CvSeq new_contour);
	/**
	 * Releases contour scanner and returns pointer to the first outer contour<br>
	 * Original signature : <code>CvSeq* cvEndFindContours(CvContourScanner*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4324</i>
	 */
	CvSeq cvEndFindContours(ImgprocLibrary.CvContourScanner scanner);
	/**
	 * Approximates a single Freeman chain or a tree of chains to polygonal curves<br>
	 * Original signature : <code>CvSeq* cvApproxChains(CvSeq*, CvMemStorage*, int, double, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4329</i>
	 */
	CvSeq cvApproxChains(CvSeq src_seq, CvMemStorage storage, int method, double parameter, int minimal_perimeter, int recursive);
	/**
	 * Initalizes Freeman chain reader.<br>
	 * The reader is used to iteratively get coordinates of all the chain points.<br>
	 * If the Freeman codes should be read as is, a simple sequence reader should be used<br>
	 * Original signature : <code>void cvStartReadChainPoints(CvChain*, CvChainPtReader*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4336</i>
	 */
	void cvStartReadChainPoints(CvChain chain, CvChainPtReader reader);
	/**
	 * Retrieves the next chain point<br>
	 * Original signature : <code>CvPoint cvReadChainPoint(CvChainPtReader*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4341</i>
	 */
	sj.opencv.jna.cxcore.CvPoint.ByValue cvReadChainPoint(CvChainPtReader reader);
	/**
	 * Approximates a single polygonal curve (contour) or<br>
	 * a tree of polygonal curves (contours)<br>
	 * Original signature : <code>CvSeq* cvApproxPoly(const void*, int, CvMemStorage*, int, double, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4347</i>
	 */
	CvSeq cvApproxPoly(Pointer src_seq, int header_size, CvMemStorage storage, int method, double parameter, int parameter2);
	/**
	 * Calculates perimeter of a contour or length of a part of contour<br>
	 * Original signature : <code>double cvArcLength(const void*, CvSlice, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4352</i>
	 */
	double cvArcLength(Pointer curve, sj.opencv.jna.cxcore.CvSlice.ByValue slice, int is_closed);
	/**
	 * Original signature : <code>double cvContourPerimeter(const void*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4356</i>
	 */
	double cvContourPerimeter(Pointer contour);
	/**
	 * Calculates contour boundning rectangle (update=1) or<br>
	 * just retrieves pre-calculated rectangle (update=0)<br>
	 * Original signature : <code>CvRect cvBoundingRect(CvArr*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4362</i>
	 */
	CvRect.ByValue cvBoundingRect(CvArr points, int update);
	/**
	 * Calculates area of a contour or contour segment<br>
	 * Original signature : <code>double cvContourArea(const CvArr*, CvSlice, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4367</i>
	 */
	double cvContourArea(Pointer contour, sj.opencv.jna.cxcore.CvSlice.ByValue slice, int oriented);
	/**
	 * Finds minimum area rotated rectangle bounding a set of points<br>
	 * Original signature : <code>CvBox2D cvMinAreaRect2(const CvArr*, CvMemStorage*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4372</i>
	 */
	sj.opencv.jna.cxcore.CvBox2D.ByValue cvMinAreaRect2(CvArr points, CvMemStorage storage);
	/**
	 * Finds minimum enclosing circle for a set of points<br>
	 * Original signature : <code>int cvMinEnclosingCircle(const CvArr*, CvPoint2D32f*, float*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4377</i><br>
	 * @deprecated use the safer methods {@link #cvMinEnclosingCircle(sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.cxcore.CvPoint2D32f, java.nio.FloatBuffer)} and {@link #cvMinEnclosingCircle(sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.cxcore.CvPoint2D32f, com.sun.jna.ptr.FloatByReference)} instead
	 */
	@Deprecated
	int cvMinEnclosingCircle(CvArr points, CvPoint2D32f center, FloatByReference radius);
	/**
	 * Finds minimum enclosing circle for a set of points<br>
	 * Original signature : <code>int cvMinEnclosingCircle(const CvArr*, CvPoint2D32f*, float*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4377</i>
	 */
	int cvMinEnclosingCircle(CvArr points, CvPoint2D32f center, FloatBuffer radius);
	/**
	 * Compares two contours by matching their moments<br>
	 * Original signature : <code>double cvMatchShapes(const void*, const void*, int, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4382</i>
	 */
	double cvMatchShapes(Pointer object1, Pointer object2, int method, double parameter);
	/**
	 * Calculates exact convex hull of 2d point set<br>
	 * Original signature : <code>CvSeq* cvConvexHull2(const CvArr*, void*, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4387</i>
	 */
	CvSeq cvConvexHull2(CvArr input, Pointer hull_storage, int orientation, int return_points);
	/**
	 * Checks whether the contour is convex or not (returns 1 if convex, 0 if not)<br>
	 * Original signature : <code>int cvCheckContourConvexity(const CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4392</i>
	 */
	int cvCheckContourConvexity(CvArr contour);
	/**
	 * Finds convexity defects for the contour<br>
	 * Original signature : <code>CvSeq* cvConvexityDefects(const CvArr*, const CvArr*, CvMemStorage*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4397</i>
	 */
	CvSeq cvConvexityDefects(CvArr contour, CvArr convexhull, CvMemStorage storage);
	/**
	 * Fits ellipse into a set of 2d points<br>
	 * Original signature : <code>CvBox2D cvFitEllipse2(const CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4402</i>
	 */
	sj.opencv.jna.cxcore.CvBox2D.ByValue cvFitEllipse2(CvArr points);
	/**
	 * Finds minimum rectangle containing two given rectangles<br>
	 * Original signature : <code>CvRect cvMaxRect(const CvRect*, const CvRect*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4407</i>
	 */
	CvRect.ByValue cvMaxRect(CvRect rect1, CvRect rect2);
	/**
	 * Finds coordinates of the box vertices<br>
	 * Original signature : <code>void cvBoxPoints(CvBox2D, CvPoint2D32f[4])</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4412</i><br>
	 * @deprecated use the safer method {@link #cvBoxPoints(sj.opencv.jna.cxcore.CvBox2D.ByValue, sj.opencv.jna.cxcore.CvPoint2D32f[])} instead
	 */
	@Deprecated
	void cvBoxPoints(sj.opencv.jna.cxcore.CvBox2D.ByValue box, Pointer pt);
	/**
	 * Finds coordinates of the box vertices<br>
	 * Original signature : <code>void cvBoxPoints(CvBox2D, CvPoint2D32f[4])</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4412</i>
	 */
	void cvBoxPoints(sj.opencv.jna.cxcore.CvBox2D.ByValue box, CvPoint2D32f pt[]);
	/**
	 * Initializes sequence header for a matrix (column or row vector) of points -<br>
	 * a wrapper for cvMakeSeqHeaderForArray (it does not initialize bounding rectangle!!!)<br>
	 * Original signature : <code>CvSeq* cvPointSeqFromMat(int, const CvArr*, CvContour*, CvSeqBlock*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4418</i>
	 */
	CvSeq cvPointSeqFromMat(int seq_kind, CvArr mat, CvContour contour_header, CvSeqBlock block);
	/**
	 * Checks whether the point is inside polygon, outside, on an edge (at a vertex).<br>
	 * Returns positive, negative or zero value, correspondingly.<br>
	 * Optionally, measures a signed distance between<br>
	 * the point and the nearest polygon edge (measure_dist=1)<br>
	 * Original signature : <code>double cvPointPolygonTest(const CvArr*, CvPoint2D32f, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4426</i>
	 */
	double cvPointPolygonTest(CvArr contour, CvPoint2D32f.ByValue pt, int measure_dist);
	/**
	 * Creates new histogram<br>
	 * Original signature : <code>CvHistogram* cvCreateHist(int, int*, int, float**, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4431</i><br>
	 * @deprecated use the safer methods {@link #cvCreateHist(int, java.nio.IntBuffer, int, com.sun.jna.ptr.PointerByReference, int)} and {@link #cvCreateHist(int, com.sun.jna.ptr.IntByReference, int, com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated
	CvHistogram cvCreateHist(int dims, IntByReference sizes, int type, PointerByReference ranges, int uniform);
	/**
	 * Creates new histogram<br>
	 * Original signature : <code>CvHistogram* cvCreateHist(int, int*, int, float**, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4431</i>
	 */
	CvHistogram cvCreateHist(int dims, int[] sizes, int type, float[][] ranges, int uniform);
	/**
	 * Assignes histogram bin ranges<br>
	 * Original signature : <code>void cvSetHistBinRanges(CvHistogram*, float**, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4436</i>
	 */
	void cvSetHistBinRanges(CvHistogram hist, PointerByReference ranges, int uniform);
	/**
	 * Creates histogram header for array<br>
	 * Original signature : <code>CvHistogram* cvMakeHistHeaderForArray(int, int*, CvHistogram*, float*, float**, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4441</i><br>
	 * @deprecated use the safer methods {@link #cvMakeHistHeaderForArray(int, java.nio.IntBuffer, sj.opencv.jna.cxcore.CvHistogram, java.nio.FloatBuffer, com.sun.jna.ptr.PointerByReference, int)} and {@link #cvMakeHistHeaderForArray(int, com.sun.jna.ptr.IntByReference, sj.opencv.jna.cxcore.CvHistogram, com.sun.jna.ptr.FloatByReference, com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated
	CvHistogram cvMakeHistHeaderForArray(int dims, IntByReference sizes, CvHistogram hist, FloatByReference data, PointerByReference ranges, int uniform);
	/**
	 * Creates histogram header for array<br>
	 * Original signature : <code>CvHistogram* cvMakeHistHeaderForArray(int, int*, CvHistogram*, float*, float**, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4441</i>
	 */
	CvHistogram cvMakeHistHeaderForArray(int dims, IntBuffer sizes, CvHistogram hist, FloatBuffer data, PointerByReference ranges, int uniform);
	/**
	 * Releases histogram<br>
	 * Original signature : <code>void cvReleaseHist(CvHistogram**)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4446</i><br>
	 * @deprecated use the safer method {@link #cvReleaseHist(sj.opencv.jna.cxcore.CvHistogram.ByReference[])} instead
	 */
	@Deprecated
	void cvReleaseHist(PointerByReference hist);
	/**
	 * Releases histogram<br>
	 * Original signature : <code>void cvReleaseHist(CvHistogram**)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4446</i>
	 */
	void cvReleaseHist(CvHistogram.ByReference hist[]);
	/**
	 * Clears all the histogram bins<br>
	 * Original signature : <code>void cvClearHist(CvHistogram*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4451</i>
	 */
	void cvClearHist(CvHistogram hist);
	/**
	 * Finds indices and values of minimum and maximum histogram bins<br>
	 * Original signature : <code>void cvGetMinMaxHistValue(const CvHistogram*, float*, float*, int*, int*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4456</i><br>
	 * @deprecated use the safer methods {@link #cvGetMinMaxHistValue(sj.opencv.jna.cxcore.CvHistogram, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #cvGetMinMaxHistValue(sj.opencv.jna.cxcore.CvHistogram, com.sun.jna.ptr.FloatByReference, com.sun.jna.ptr.FloatByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	void cvGetMinMaxHistValue(CvHistogram hist, FloatByReference min_value, FloatByReference max_value, IntByReference min_idx, IntByReference max_idx);
	/**
	 * Finds indices and values of minimum and maximum histogram bins<br>
	 * Original signature : <code>void cvGetMinMaxHistValue(const CvHistogram*, float*, float*, int*, int*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4456</i>
	 */
	void cvGetMinMaxHistValue(CvHistogram hist, FloatBuffer min_value, FloatBuffer max_value, IntBuffer min_idx, IntBuffer max_idx);
	/**
	 * Normalizes histogram by dividing all bins by sum of the bins, multiplied by <factor>.<br>
	 * After that sum of histogram bins is equal to <factor><br>
	 * Original signature : <code>void cvNormalizeHist(CvHistogram*, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4462</i>
	 */
	void cvNormalizeHist(CvHistogram hist, double factor);
	/**
	 * Clear all histogram bins that are below the threshold<br>
	 * Original signature : <code>void cvThreshHist(CvHistogram*, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4467</i>
	 */
	void cvThreshHist(CvHistogram hist, double threshold);
	/**
	 * Compares two histogram<br>
	 * Original signature : <code>double cvCompareHist(const CvHistogram*, const CvHistogram*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4472</i>
	 */
	double cvCompareHist(CvHistogram hist1, CvHistogram hist2, int method);
	/**
	 * Copies one histogram to another. Destination histogram is created if<br>
	 * the destination pointer is NULL<br>
	 * Original signature : <code>void cvCopyHist(const CvHistogram*, CvHistogram**)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4478</i><br>
	 * @deprecated use the safer method {@link #cvCopyHist(sj.opencv.jna.cxcore.CvHistogram, sj.opencv.jna.cxcore.CvHistogram.ByReference[])} instead
	 */
	@Deprecated
	void cvCopyHist(CvHistogram src, PointerByReference dst);
	/**
	 * Copies one histogram to another. Destination histogram is created if<br>
	 * the destination pointer is NULL<br>
	 * Original signature : <code>void cvCopyHist(const CvHistogram*, CvHistogram**)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4478</i>
	 */
	void cvCopyHist(CvHistogram src, CvHistogram.ByReference dst[]);
	/**
	 * Calculates bayesian probabilistic histograms<br>
	 * (each or src and dst is an array of <number> histograms<br>
	 * Original signature : <code>void cvCalcBayesianProb(CvHistogram**, int, CvHistogram**)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4484</i><br>
	 * @deprecated use the safer method {@link #cvCalcBayesianProb(sj.opencv.jna.cxcore.CvHistogram.ByReference[], int, sj.opencv.jna.cxcore.CvHistogram.ByReference[])} instead
	 */
	@Deprecated
	void cvCalcBayesianProb(PointerByReference src, int number, PointerByReference dst);
	/**
	 * Calculates bayesian probabilistic histograms<br>
	 * (each or src and dst is an array of <number> histograms<br>
	 * Original signature : <code>void cvCalcBayesianProb(CvHistogram**, int, CvHistogram**)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4484</i>
	 */
	void cvCalcBayesianProb(CvHistogram.ByReference src[], int number, CvHistogram.ByReference dst[]);
	/**
	 * Calculates array histogram<br>
	 * Original signature : <code>void cvCalcArrHist(CvArr**, CvHistogram*, int, const CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4489</i>
	 */
	void cvCalcArrHist(JNAIplImage.ByReference arr, CvHistogram.ByReference hist, int accumulate, CvArr mask);
	/**
	 * Original signature : <code>void cvCalcHist(IplImage**, CvHistogram*, int, const CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4493</i><br>
	 * @deprecated use the safer method {@link #cvCalcHist(sj.opencv.jna.cxcore.JNAIplImage.ByReference[], sj.opencv.jna.cxcore.CvHistogram, int, sj.opencv.jna.highgui.HighguiLibrary.CvArr)} instead
	 */
	@Deprecated
	void cvCalcHist(PointerByReference image, CvHistogram hist, int accumulate, CvArr mask);
	/**
	 * Original signature : <code>void cvCalcHist(IplImage**, CvHistogram*, int, const CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4493</i>
	 */
	void cvCalcHist(JNAIplImage.ByReference image, CvHistogram.ByReference hist, int accumulate, CvArr mask);
	/**
	 * Calculates back project<br>
	 * Original signature : <code>void cvCalcArrBackProject(CvArr**, CvArr*, const CvHistogram*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4498</i>
	 */
	void cvCalcArrBackProject(PointerByReference image, CvArr dst, CvHistogram hist);
	/**
	 * Does some sort of template matching but compares histograms of<br>
	 * template and each window location<br>
	 * Original signature : <code>void cvCalcArrBackProjectPatch(CvArr**, CvArr*, CvSize, CvHistogram*, int, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4504</i>
	 */
	void cvCalcArrBackProjectPatch(PointerByReference image, CvArr dst, CvSize.ByValue range, CvHistogram hist, int method, double factor);
	/**
	 * calculates probabilistic density (divides one histogram by another)<br>
	 * Original signature : <code>void cvCalcProbDensity(const CvHistogram*, const CvHistogram*, CvHistogram*, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4509</i>
	 */
	void cvCalcProbDensity(CvHistogram hist1, CvHistogram hist2, CvHistogram dst_hist, double scale);
	/**
	 * equalizes histogram of 8-bit single-channel image<br>
	 * Original signature : <code>void cvEqualizeHist(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4514</i>
	 */
	void cvEqualizeHist(CvArr src, CvArr dst);
	/**
	 * Applies distance transform to binary image<br>
	 * Original signature : <code>void cvDistTransform(const CvArr*, CvArr*, int, int, const float*, CvArr*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4519</i><br>
	 * @deprecated use the safer methods {@link #cvDistTransform(sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.highgui.HighguiLibrary.CvArr, int, int, float[], sj.opencv.jna.highgui.HighguiLibrary.CvArr, int)} and {@link #cvDistTransform(sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.highgui.HighguiLibrary.CvArr, int, int, com.sun.jna.ptr.FloatByReference, sj.opencv.jna.highgui.HighguiLibrary.CvArr, int)} instead
	 */
	@Deprecated
	void cvDistTransform(CvArr src, CvArr dst, int distance_type, int mask_size, FloatByReference mask, CvArr labels, int labelType);
	/**
	 * Applies distance transform to binary image<br>
	 * Original signature : <code>void cvDistTransform(const CvArr*, CvArr*, int, int, const float*, CvArr*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4519</i>
	 */
	void cvDistTransform(CvArr src, CvArr dst, int distance_type, int mask_size, float mask[], CvArr labels, int labelType);
	/**
	 * Applies fixed-level threshold to grayscale image.<br>
	 * This is a basic operation applied before retrieving contours<br>
	 * Original signature : <code>double cvThreshold(const CvArr*, CvArr*, double, double, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4525</i>
	 */
	double cvThreshold(CvArr src, CvArr dst, double threshold, double max_value, int threshold_type);
	/**
	 * Applies adaptive threshold to grayscale image.<br>
	 * The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and<br>
	 * CV_ADAPTIVE_THRESH_GAUSSIAN_C are:<br>
	 * neighborhood size (3, 5, 7 etc.),<br>
	 * and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...)<br>
	 * Original signature : <code>void cvAdaptiveThreshold(const CvArr*, CvArr*, double, int, int, int, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4534</i>
	 */
	void cvAdaptiveThreshold(CvArr src, CvArr dst, double max_value, int adaptive_method, int threshold_type, int block_size, double param1);
	/**
	 * Fills the connected component until the color difference gets large enough<br>
	 * Original signature : <code>void cvFloodFill(CvArr*, CvPoint, CvScalar, CvScalar, CvScalar, CvConnectedComp*, int, CvArr*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4539</i>
	 */
	void cvFloodFill(CvArr image, sj.opencv.jna.cxcore.CvPoint.ByValue seed_point, sj.opencv.jna.cxcore.CvScalar.ByValue new_val, sj.opencv.jna.cxcore.CvScalar.ByValue lo_diff, sj.opencv.jna.cxcore.CvScalar.ByValue up_diff, CvConnectedComp comp, int flags, CvArr mask);
	/**
	 * Runs canny edge detector<br>
	 * Original signature : <code>void cvCanny(const CvArr*, CvArr*, double, double, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4544</i>
	 */
	void cvCanny(CvArr image, CvArr edges, double threshold1, double threshold2, int aperture_size);
	/**
	 * Calculates constraint image for corner detection<br>
	 * Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy.<br>
	 * Applying threshold to the result gives coordinates of corners<br>
	 * Original signature : <code>void cvPreCornerDetect(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4551</i>
	 */
	void cvPreCornerDetect(CvArr image, CvArr corners, int aperture_size);
	/**
	 * Calculates eigen values and vectors of 2x2<br>
	 * gradient covariation matrix at every image pixel<br>
	 * Original signature : <code>void cvCornerEigenValsAndVecs(const CvArr*, CvArr*, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4557</i>
	 */
	void cvCornerEigenValsAndVecs(CvArr image, CvArr eigenvv, int block_size, int aperture_size);
	/**
	 * Calculates minimal eigenvalue for 2x2 gradient covariation matrix at<br>
	 * every image pixel<br>
	 * Original signature : <code>void cvCornerMinEigenVal(const CvArr*, CvArr*, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4563</i>
	 */
	void cvCornerMinEigenVal(CvArr image, CvArr eigenval, int block_size, int aperture_size);
	/**
	 * Harris corner detector:<br>
	 * Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel<br>
	 * Original signature : <code>void cvCornerHarris(const CvArr*, CvArr*, int, int, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4569</i>
	 */
	void cvCornerHarris(CvArr image, CvArr harris_responce, int block_size, int aperture_size, double k);
	/**
	 * Adjust corner position using some sort of gradient search<br>
	 * Original signature : <code>void cvFindCornerSubPix(const CvArr*, CvPoint2D32f*, int, CvSize, CvSize, CvTermCriteria)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4574</i>
	 */
	void cvFindCornerSubPix(CvArr image, CvPoint2D32f corners, int count, CvSize.ByValue win, CvSize.ByValue zero_zone, sj.opencv.jna.cxcore.CvTermCriteria.ByValue criteria);
	/**
	 * Finds a sparse set of points within the selected region<br>
	 * that seem to be easy to track<br>
	 * Original signature : <code>void cvGoodFeaturesToTrack(const CvArr*, CvArr*, CvArr*, CvPoint2D32f*, int*, double, double, const CvArr*, int, int, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4580</i><br>
	 * @deprecated use the safer methods {@link #cvGoodFeaturesToTrack(sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.cxcore.CvPoint2D32f, java.nio.IntBuffer, double, double, sj.opencv.jna.highgui.HighguiLibrary.CvArr, int, int, double)} and {@link #cvGoodFeaturesToTrack(sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.highgui.HighguiLibrary.CvArr, sj.opencv.jna.cxcore.CvPoint2D32f, com.sun.jna.ptr.IntByReference, double, double, sj.opencv.jna.highgui.HighguiLibrary.CvArr, int, int, double)} instead
	 */
	@Deprecated
	void cvGoodFeaturesToTrack(CvArr image, CvArr eig_image, CvArr temp_image, CvPoint2D32f corners, IntByReference corner_count, double quality_level, double min_distance, CvArr mask, int block_size, int use_harris, double k);
	/**
	 * Finds a sparse set of points within the selected region<br>
	 * that seem to be easy to track<br>
	 * Original signature : <code>void cvGoodFeaturesToTrack(const CvArr*, CvArr*, CvArr*, CvPoint2D32f*, int*, double, double, const CvArr*, int, int, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4580</i>
	 */
	void cvGoodFeaturesToTrack(CvArr image, CvArr eig_image, CvArr temp_image, CvPoint2D32f corners, IntBuffer corner_count, double quality_level, double min_distance, CvArr mask, int block_size, int use_harris, double k);
	/**
	 * Finds lines on binary image using one of several methods.<br>
	 * line_storage is either memory storage or 1 x <max number of lines> CvMat, its<br>
	 * number of columns is changed by the function.<br>
	 * method is one of CV_HOUGH_*;<br>
	 * rho, theta and threshold are used for each of those methods;<br>
	 * param1 ~ line length, param2 ~ line gap - for probabilistic,<br>
	 * param1 ~ srn, param2 ~ stn - for multi-scale<br>
	 * Original signature : <code>CvSeq* cvHoughLines2(CvArr*, void*, int, double, double, int, double, double)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4591</i>
	 */
	CvSeq cvHoughLines2(CvArr image, Pointer line_storage, int method, double rho, double theta, int threshold, double param1, double param2);
	/**
	 * Finds circles in the image<br>
	 * Original signature : <code>CvSeq* cvHoughCircles(CvArr*, void*, int, double, double, double, double, int, int)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4596</i>
	 */
	CvSeq cvHoughCircles(CvArr image, Pointer circle_storage, int method, double dp, double min_dist, double param1, double param2, int min_radius, int max_radius);
	/**
	 * Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)<br>
	 * Original signature : <code>void cvFitLine(const CvArr*, int, double, double, double, float*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4601</i><br>
	 * @deprecated use the safer methods {@link #cvFitLine(sj.opencv.jna.highgui.HighguiLibrary.CvArr, int, double, double, double, java.nio.FloatBuffer)} and {@link #cvFitLine(sj.opencv.jna.highgui.HighguiLibrary.CvArr, int, double, double, double, com.sun.jna.ptr.FloatByReference)} instead
	 */
	@Deprecated
	void cvFitLine(CvArr points, int dist_type, double param, double reps, double aeps, FloatByReference line);
	/**
	 * Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)<br>
	 * Original signature : <code>void cvFitLine(const CvArr*, int, double, double, double, float*)</code><br>
	 * <i>native declaration : modules/imgproc/include/opencv2/imgproc/imgproc_c.h:4601</i>
	 */
	void cvFitLine(CvArr points, int dist_type, double param, double reps, double aeps, FloatBuffer line);
	public static class CvContourScanner extends PointerType {
		public CvContourScanner(Pointer address) {
			super(address);
		}
		public CvContourScanner() {
			super();
		}
	};
}
